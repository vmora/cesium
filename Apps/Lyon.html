<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version (or Chrome Frame if pre-IE11). -->
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>Hello World!</title>
  <script src="../Build/CesiumUnminified/Cesium.js"></script>
  <style>
      @import url(../Build/Cesium/Widgets/widgets.css);
      html, body, #cesiumContainer {
          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <script>

/*
    var defaultCrsFunction = function(coordinates) {
        return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);
    }


    var DemoTileProvider = function DemoTileProvider() {
        this._quadtree = undefined;
        this._tilingScheme = new Cesium.GeographicTilingScheme();
        this._errorEvent = new Cesium.Event();
        this._levelZeroMaximumError = Cesium.QuadtreeTileProvider.computeDefaultLevelZeroMaximumGeometricError(this._tilingScheme);
    };

    Object.defineProperties(DemoTileProvider.prototype, {
        quadtree : {
            get : function() {
                return this._quadtree;
            },
            set : function(value) {
                this._quadtree = value;
            }
        },

        ready : {
            get : function() {
                return true;
            }
        },

        tilingScheme : {
            get : function() {
                return this._tilingScheme;
            }
        },

        errorEvent : {
            get : function() {
                return this._errorEvent;
            }
        }
    });

    DemoTileProvider.prototype.beginUpdate = function(context, frameState, commandList) {
    };

    DemoTileProvider.prototype.endUpdate = function(context, frameState, commandList) {
    };

    DemoTileProvider.prototype.getLevelMaximumGeometricError = function(level) {
        return this._levelZeroMaximumError / (1 << level);
    };

    DemoTileProvider.prototype.loadTile = function(context, frameState, tile) {
        if (tile.state === Cesium.QuadtreeTileLoadState.START) {
            tile.data = {
                primitive : undefined,
                freeResources : function() {
                    if (Cesium.defined(this.primitive)) {
                        this.primitive.destroy();
                        this.primitive = undefined;
                    }
                }
            };

    var load = function(that, geoJson, sourceUri, options) {
      if (geoJson.features.length) console.debug("loaded ",geoJson.features.length);

      var coordinatesArrayToCartesianArray = function(coordinates) {
          var positions = new Array(coordinates.length);
          for (var i = 0; i < coordinates.length; i++) {
              positions[i] = Cesium.Cartesian3.fromDegrees(coordinates[i][0], coordinates[i][1], coordinates[i][2] );
          }
          return positions;
      }

      var color = Cesium.Color.fromBytes(255, 255, 255, 255);
      var primCol = new Cesium.PrimitiveCollection();
      for (var f = 0; f < geoJson.features.length; f++){
        var geoInstances = [];
        var texRe = /\((.*),"(.*)"\)/;
        var texP = texRe.exec(geoJson.features[f].properties.tex);
        //console.debug("texture", texP[1]);

        var mat = new Cesium.Material({
                fabric : {
                    type : 'DiffuseMap',
                    uniforms : {
                        image : texP[1]
                    }
                }
            });

        for (var p = 0; p < geoJson.features[f].geometry.coordinates.length; p++){


            //var hierarchy = new Cesium.PolygonHierarchy(coordinatesArrayToCartesianArray( geoJson.features[f].geometry.coordinates[p][0]));
            //var pgeom = new Cesium.PolygonGeometry( {
            //    polygonHierarchy : hierarchy, 
            //    perPositionHeight : true//,
            //    //vertexFormat : new Cesium.VertexFormat({st : true, normal : true })
            //} );
            //
            //
            //var geom = Cesium.PolygonGeometry.createGeometry(pgeom);
            var geom = Cesium.TinGeometry.createGeometry({ 
                position: geoJson.features[f].geometry.coordinates,
                st: JSON.parse(texP[2].replace("{","[","g").replace("}","]","g"))
                });

            //console.debug( "vtx len ", geom.textureCoordinates );
            geoInstances.push( new Cesium.GeometryInstance({
              geometry : pgeom
            }) );

        }
        primCol.add(new Cesium.Primitive({
              geometryInstances : geoInstances,
              appearance : new Cesium.MaterialAppearance({
                  material : mat,//Cesium.Material.fromType('Color'),
                  faceForward : true
                })
          }));
      }

      var color = Cesium.Color.fromBytes(255, 0, 0, 255);
      //if (!geoInstances.length){
      //    geoInstances.push( new Cesium.GeometryInstance({
      //          geometry : new Cesium.RectangleOutlineGeometry({
      //                rectangle : tile.rectangle
      //            }),
      //          attributes : {
      //              color : Cesium.ColorGeometryInstanceAttribute.fromColor(color)
      //          }
      //        }) );
      //}
      //if (hierarchy) console.debug("loaded ",hierarchy);
      //console.debug("loaded "+geoJson.features.length()+ " features");

      if (primCol.length){
          options.tile.data.primitive = primCol;
       }else{
        var color = Cesium.Color.fromBytes(255, 0, 0, 255);
        options.tile.data.primitive = new Cesium.Primitive({
            geometryInstances : new Cesium.GeometryInstance({
                geometry : new Cesium.RectangleOutlineGeometry({
                    rectangle : options.tile.rectangle
                }),
                attributes : {
                    color : Cesium.ColorGeometryInstanceAttribute.fromColor(color)
                }
            }),
            appearance : new Cesium.PerInstanceColorAppearance({
                flat : true
            })
        });
      
       }

      options.tile.data.boundingSphere3D = Cesium.BoundingSphere.fromRectangle3D(options.tile.rectangle);
      options.tile.data.boundingSphere2D = Cesium.BoundingSphere.fromRectangle2D(options.tile.rectangle, frameState.mapProjection);
      Cesium.Cartesian3.fromElements(options.tile.data.boundingSphere2D.center.z, options.tile.data.boundingSphere2D.center.x, options.tile.data.boundingSphere2D.center.y, options.tile.data.boundingSphere2D.center);
      options.tile.data.primitive.update(options.context, options.frameState, []);
      options.tile.state = Cesium.QuadtreeTileLoadState.DONE;
      options.tile.renderable = true;
    };


    var loadUrl = function(url, options) {
      console.debug(url);
        var that = this;
        Cesium.when(Cesium.loadJson(url), function(geoJson) {
            load(tile, geoJson, url, options);
        }).otherwise(function(error) {
            that._error.raiseEvent(that, error);
            Cesium.when.reject(error);
        });
    };

    var DEGREES_PER_RADIAN = 180.0 / Math.PI;
    var RADIAN_PER_DEGREEE = 1 / DEGREES_PER_RADIAN;
    var centroidGid1 = {lat:4.85313065565722*RADIAN_PER_DEGREEE, lon: 45.758225029663};

    if ( Math.abs(tile.rectangle.south - tile.rectangle.north) < .0001 ){
              tile.state = Cesium.QuadtreeTileLoadState.LOADING;
              //loadUrl("http://localhost/cgi-bin/tinyows?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&outputFormat=JSON&typeName=tows:textured_citygml_lat_long&srsName=EPSG:4326&featureId=1",{tile : tile, context : context, frameState : frameState});
              loadUrl("http://localhost/cgi-bin/tinyows?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&outputFormat=JSON&typeName=tows:textured_citygml_lat_long&srsName=EPSG:4326&BBOX="+
                  DEGREES_PER_RADIAN*tile.rectangle.west+","+
                  DEGREES_PER_RADIAN*tile.rectangle.south+","+
                  DEGREES_PER_RADIAN*tile.rectangle.east+","+
                  DEGREES_PER_RADIAN*tile.rectangle.north, {tile : tile, context : context, frameState : frameState});
    }
    else{
      //console.debug(Math.abs(tile.rectangle.south - tile.rectangle.north));
        var color = Cesium.Color.fromBytes(255, 0, 0, 255);
        tile.data.primitive = new Cesium.Primitive({
            geometryInstances : new Cesium.GeometryInstance({
                geometry : new Cesium.RectangleOutlineGeometry({
                    rectangle : tile.rectangle
                }),
                attributes : {
                    color : Cesium.ColorGeometryInstanceAttribute.fromColor(color)
                }
            }),
            appearance : new Cesium.PerInstanceColorAppearance({
                flat : true
            })
        });

        tile.data.boundingSphere3D = Cesium.BoundingSphere.fromRectangle3D(tile.rectangle);
        tile.data.boundingSphere2D = Cesium.BoundingSphere.fromRectangle2D(tile.rectangle, frameState.mapProjection);
        Cesium.Cartesian3.fromElements(tile.data.boundingSphere2D.center.z, tile.data.boundingSphere2D.center.x, tile.data.boundingSphere2D.center.y, tile.data.boundingSphere2D.center);

        tile.data.primitive.update(context, frameState, []);
        tile.state = Cesium.QuadtreeTileLoadState.DONE;
        tile.renderable = true;
    }


        }

        //if (tile.state === Cesium.QuadtreeTileLoadState.LOADING) {
        //    tile.data.primitive.update(context, frameState, []);
        //    if (tile.data.primitive.ready) {
        //        tile.state = Cesium.QuadtreeTileLoadState.DONE;
        //        tile.renderable = true;
        //    }
        //}
    };

    DemoTileProvider.prototype.computeTileVisibility = function(tile, frameState, occluders) {
        var boundingSphere;
        if (frameState.mode === Cesium.SceneMode.SCENE3D) {
            boundingSphere = tile.data.boundingSphere3D;
        } else {
            boundingSphere = tile.data.boundingSphere2D;
        }

        return frameState.cullingVolume.computeVisibility(boundingSphere);
    };

    DemoTileProvider.prototype.showTileThisFrame = function(tile, context, frameState, commandList) {
        tile.data.primitive.update(context, frameState, commandList);
    };

    var subtractScratch = new Cesium.Cartesian3();

    DemoTileProvider.prototype.computeDistanceToTile = function(tile, frameState) {
        var boundingSphere;

        if (frameState.mode === Cesium.SceneMode.SCENE3D) {
            boundingSphere = tile.data.boundingSphere3D;
        } else {
            boundingSphere = tile.data.boundingSphere2D;
        }

        return Math.max(0.0, Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(boundingSphere.center, frameState.camera.positionWC, subtractScratch)) - boundingSphere.radius);
    };

    DemoTileProvider.prototype.isDestroyed = function() {
        return false;
    };

    DemoTileProvider.prototype.destroy = function() {
        return Cesium.destroyObject(this);
    };
*/


    var viewer = new Cesium.Viewer('cesiumContainer');

    //viewer.dataSources.add(Cesium.GeoJsonDataSource.fromUrl('http://localhost/cgi-bin/tinyows?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&outputFormat=JSON&typeName=tows:textured_citygml&srsName=EPSG:4326&BBOX=4.77891738954122,45.7097114184435,4.92619849285373,45.8081159508728'));
    //viewer.dataSources.add(Cesium.GeoJsonDataSource.fromUrl('http://localhost/cgi-bin/tinyows?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&outputFormat=JSON&typeName=tows:textured_citygml&featureID=tows:textured_citygml.2&srsName=EPSG:4326'));

    var west = 4.84;
    var south = 45.75;
    var east = 4.86;
    var north = 45.76;

    var rectangle = Cesium.Rectangle.fromDegrees(west, south, east, north);
    viewer.camera.viewRectangle(rectangle);

    var scene = viewer.scene;

    var primitives = scene.primitives;

    var primCol = new Cesium.PrimitiveCollection();

    var a = Cesium.Cartesian3.fromDegrees(4,45,500);
    var b = Cesium.Cartesian3.fromDegrees(4,46,500);
    var c = Cesium.Cartesian3.fromDegrees(5,46,500);
    var d = Cesium.Cartesian3.fromDegrees(5,45,500);
    var pgeom = new Cesium.PolygonGeometry( {
        polygonHierarchy : new Cesium.PolygonHierarchy([a, b, c]), 
        perPositionHeight : true,
        //vertexFormat : new Cesium.VertexFormat({st : true, normal : true })
    } );

    var url = "http://localhost/cgi-bin/tinyows?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&outputFormat=JSON&typeName=tows:textured_citygml_lat_long&BBOX="+west+","+south+","+east+","+north;
    Cesium.when(Cesium.loadJson(url), function(geoJson) {
        var texRe = /\((.*),"(.*)"\)/;

        for (var f=0; f < geoJson.features.length; f++){
            var texP = texRe.exec(geoJson.features[f].properties.tex);
            var st = JSON.parse(texP[2].replace("{","[","g").replace("}","]","g"));
            var geom = new Cesium.TinGeometry({
                  position: geoJson.features[f].geometry.coordinates,//[[[a.x, a.y, a.z],[b.x,b.y,b.z],[c.x,c.y,c.z],[a.x, a.y, a.z]]],
                  //position: [[[[west,south,500],[east,south,500],[east,north,500],[west,south,500]]],[[[west,south,500],[east,north,500],[west,north,500],[west,south,500]]]],
                  st : st//[[0,0],[1,0],[1,1],[0,0],[0,0],[1,1],[0,1],[0,0]]
                  });
            console.debug("Tin geom", geom);

            var mat = new Cesium.Material({
                    fabric : {
                        type : 'DiffuseMap',
                        uniforms : {
                            image : texP[1]
                        }
                    }
                });
            primCol.add(new Cesium.Primitive({
                  geometryInstances : new Cesium.GeometryInstance({ geometry : geom }) ,
                  appearance : new Cesium.MaterialAppearance({
                      material : mat,//Cesium.Material.fromType('Color'),
                      //color : Cesium.Color.fromBytes(255, 0, 0, 255),
                      faceForward : true
                    })
              }));
        }

        //primitives.add(new Cesium.QuadtreePrimitive({
        //    tileProvider : new DemoTileProvider()
        //}));
        primitives.add( primCol );
    })

    var globe = scene.globe;
    scene.fxaa = true;
    globe.depthTestAgainstTerrain = true;

    var cesiumTerrainProviderMeshes = new Cesium.CesiumTerrainProvider({
        url : '//cesiumjs.org/stk-terrain/tilesets/world/tiles'
    });

    viewer.terrainProvider = cesiumTerrainProviderMeshes;
  </script>
</body>
</html>
